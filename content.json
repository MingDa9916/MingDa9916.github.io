{"meta":{"title":"TianSan","subtitle":"❤小魔王的学习笔记❤","description":"马革裹尸 向死而生","author":"TianSan","url":"https://MingDa9916.github.io","root":"/"},"pages":[{"title":"Photo","date":"2017-04-04T14:14:07.000Z","updated":"2019-05-13T16:23:43.605Z","comments":false,"path":"Photo/index.html","permalink":"https://MingDa9916.github.io/Photo/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-13T15:11:54.000Z","updated":"2019-05-13T15:15:33.499Z","comments":true,"path":"tags/index.html","permalink":"https://MingDa9916.github.io/tags/index.html","excerpt":"","text":""},{"title":"归档","date":"2019-05-13T15:17:32.000Z","updated":"2019-05-13T15:18:14.538Z","comments":true,"path":"categories/index.html","permalink":"https://MingDa9916.github.io/categories/index.html","excerpt":"","text":""},{"title":"Lover","date":"2019-05-09T02:57:03.000Z","updated":"2019-05-13T15:19:32.228Z","comments":true,"path":"Lover/index.html","permalink":"https://MingDa9916.github.io/Lover/index.html","excerpt":"","text":""}],"posts":[{"title":"队列","slug":"队列","date":"2019-08-27T11:17:30.000Z","updated":"2019-08-27T12:22:50.624Z","comments":true,"path":"2019/08/27/队列/","link":"","permalink":"https://MingDa9916.github.io/2019/08/27/队列/","excerpt":"","text":"队列基础操作 1、循环队列初始化 123void InitQuenue (SqQuence &amp;Q)&#123; Q.reae = Q.front = 0;&#125; 1、循环队列判断空 1234bool is Empty(SqQueue Q)&#123; if (Q.rear == Q.Front) reeturn true; else return false;&#125; 1、循环队列入队 123456bool EnQueue(SqQueue &amp;Q ,Elemtype x)&#123;if (Q.rear == Q.Front) return false;Q.data[Q.rear] = x;Q.rear = (Q.rear+1)%MaxSize;return true&#125; 1、循环队列出队 12345678bool DeQueue(SqQueue &amp;Q ,ElemType &amp;x)&#123; if (Q.rear == Q.Front) return false; else&#123; x = Q.data[Q.Front]; Q.Front = (Q.Front-1+MaxSize)%MaxSize; return ture; &#125;&#125; 1、队列的链式储存结构 12345678typedef struct&#123;Elemtype data;struct LinkNode *next;&#125;LinkNode;typedef struct&#123; LinkNode *rear; LinkNode *Front;&#125;LinkQueue; 链式队列初始化 1234void InitQueue(LinkQueue &amp;Q)&#123; Q.rear = Q.Front = (LinkNode*)malloc(sixeofs(LinkNode)); Q.Front = NULL;&#125; 链式队列判空 1234bool IsEmpty (LinkQueue Q)&#123; if (Q.rear = Q.Front) return false; else return true;&#125; 链式链表入队 1234567bool EnQueue (SeQueue &amp;Q , Elemtype &amp;x)&#123; LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode)); s-&gt;next = NULL; s-&gt;data = x; Q.rear-&gt;next = s; Q.rear = s;&#125;","categories":[{"name":"王道数据结构","slug":"王道数据结构","permalink":"https://MingDa9916.github.io/categories/王道数据结构/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://MingDa9916.github.io/tags/队列/"}]},{"title":"算法笔记_C/C++入门","slug":"算法笔记-C-C-入门","date":"2019-07-08T10:08:50.000Z","updated":"2019-07-08T10:08:50.462Z","comments":true,"path":"2019/07/08/算法笔记-C-C-入门/","link":"","permalink":"https://MingDa9916.github.io/2019/07/08/算法笔记-C-C-入门/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"王道_队列_基础","slug":"王道-队列-基础","date":"2019-07-08T10:08:21.000Z","updated":"2019-07-08T10:08:21.591Z","comments":true,"path":"2019/07/08/王道-队列-基础/","link":"","permalink":"https://MingDa9916.github.io/2019/07/08/王道-队列-基础/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"王道_栈_习题","slug":"王道-栈-习题","date":"2019-07-08T10:07:58.000Z","updated":"2019-07-08T11:05:49.946Z","comments":true,"path":"2019/07/08/王道-栈-习题/","link":"","permalink":"https://MingDa9916.github.io/2019/07/08/王道-栈-习题/","excerpt":"","text":"1、IO进栈出栈为空栈合法性判别。 1234567891011121314151617181920int Judge (char A[])&#123; int i = 0; int j = k = 0; while (A[i])&#123; switch (A[i])&#123; case &apos;I&apos;: k++; break; case &apos;O&apos;: j++; if (j&gt;k)&#123; printf (&quot;出入栈非法！/n&quot;)； return 0； &#125; &#125; i++; &#125; if (j!=k)&#123; printf (&quot;队列不合法！/n&quot;)； return 0； &#125; else printf (&quot;队列合法！/n&quot;)&#125; 2、单链表头指针为L，结点结构体是data&amp;next，现判断其是否对称？ 12345678910111213141516171819int DC_Char(LinkList&amp; L, int n)&#123;//由于已经给了单链表长度就不用侧脸其长度了char A[n/2];int i = 0;p = L-&gt;next;for (;i&lt;n/2;i++)&#123; A[i] = p-&gt;data; p = p-&gt;next;&#125;i--;if (n%2 == 1)p = p-&gt;next;while(p!=NULL&amp;&amp;A[i]==p-&gt;data)&#123; i--; p = p-&gt;next;&#125;i++;if (i==0)return 1;else &#123;printf (&quot;不对称！/n&quot;);return 0;&#125;&#125; 共享栈的结构体定义、进栈、出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define maxsize 100#define Elemtype int//结构体定义typedef struct &#123; ElemType stack[maxsize]; int top[2];&#125; stk;stk s ;//进栈bool PushStack(ElemType x, int i)&#123; if (i != 0 || i != 1)&#123; printf(&quot;栈号错误！/n&quot;) exit(0); &#125; switch (i)&#123; case 0 : if (s.top[0]-s.top[0]==1)&#123; printf (&quot;栈满！/n&quot;)； return 0; &#125; else s.stack[++top[0]]=x; &#125; case 1 : if (s.top[1]-s.top[0]==1)&#123; printf (&quot;栈满！/n&quot;)； return 0; &#125; else s.stack[--top[0]]=x; &#125;&#125;//出栈bool PopStack(ElemType x, int i)&#123; if (i != 0 || i != 1)&#123; printf(&quot;栈号错误！/n&quot;) exit(0); &#125; if(s.stxck[s.top[0]]&lt;=-1 || s.stxck[s.top[0]]&gt;=maxsize) return 0; switch (i)&#123; case 1: &#123; x = s.stack[s.top[1]]; --s.top[1]; return 1; &#125; case 0: &#123; x = s.stack[s.top[0]]; --s.top[0]; return 1; &#125; &#125;&#125;","categories":[{"name":"王道数据结构","slug":"王道数据结构","permalink":"https://MingDa9916.github.io/categories/王道数据结构/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://MingDa9916.github.io/tags/栈/"}]},{"title":"黑马数据结构","slug":"黑马数据结构","date":"2019-07-04T11:19:32.000Z","updated":"2019-07-04T13:34:54.554Z","comments":true,"path":"2019/07/04/黑马数据结构/","link":"","permalink":"https://MingDa9916.github.io/2019/07/04/黑马数据结构/","excerpt":"","text":"动态数组1、写一个动态数组必须关心的数据123451、开辟内存的首地址2、元素的个数（好处：我们大概知道当前空间中要存的元素）3、元素的类型，数组容量。不关心数组类型我全部放void *， 为什么用void * 因为数组要实现的任务是能存储任何类型的数据类型，C语言中无论什么数据类型他都有地址，存他的第地址通过地址找元素。当用户插入或删除一个数据时我存起来的是元素的地址，并没有把数据拷贝出来放到我的容器里。数组里面存的用户的开辟数据的地址，用户开辟大数据如果开辟到堆上，释放数组时候可以将其释放，如果开辟到栈上释放掉就放着翻车了，所以，数组的唯一目的就是将用户的数据串联起来，串联成数组串联成链表串联成二叉树，内存释放与否不管。4、动态数组类型定义为void** 12345678910111213141516171819202122232425262728293031323334353637383940414243#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;//先把所需要的数据信息结构定义下来，接下来提供的任何的接口函数，都是对结构体中的元素操作。struct DynamicArray&#123; //数组存储元素的空间的首地址 void **addr;; //存储数据的内存中最大能容纳多少元素 int capacity;//容量 //当前存储数据的内存中有多少个元素 int size; //大小&#125;；//接下来所有的接口、函数，都是针对这个结构体进行操作，因为这个结构体包括了数组的一切信息。int main()&#123;//初始化数组，返回一个结构体（就相当于造个指针），返回一个什么样子的结构体呢？需要初始化标识。struct DynamicArray *Init_DynamicArray(int capacity)//struct DynamicArray——构造出什么样结构的数组；Init_DynamicArray(int capacity)——怎么初始化。&#123; if(capacity &lt;=0) &#123; return NULL; &#125; struct DynamicArray *arr = malloc(sizeof(struct DynamiacArray)); if (NULL==arr) &#123; return NULL； &#125; arr-&gt;capacity = capacity; arr-&gt;addr = mallloc(sizeof(void *)*arr-&gt;capacity);&#125;//插入元素——定义了插入元素的函数void Insert(struct DynamicArray *arr, int pos, void *data);//遍历——遍历函数void Froeach(struct DynamicArray *arr,void(*_callback)(void *))&#123;&#125; system(&quot;pause&quot;); return EXIT_SUCCESS;&#125;","categories":[{"name":"Day One","slug":"Day-One","permalink":"https://MingDa9916.github.io/categories/Day-One/"}],"tags":[{"name":"黑马数据结构","slug":"黑马数据结构","permalink":"https://MingDa9916.github.io/tags/黑马数据结构/"}]},{"title":"经典语录","slug":"经典语录","date":"2019-06-23T12:17:05.000Z","updated":"2019-07-10T13:07:35.106Z","comments":true,"path":"2019/06/23/经典语录/","link":"","permalink":"https://MingDa9916.github.io/2019/06/23/经典语录/","excerpt":"","text":"1、一看你的样子就是除了好事什么都敢做，你只差一个机会，有件事情找你帮忙。赴汤蹈火啊。—–周星驰《功夫》 2、whatever area that you get into, even if you’re the best of the best, there’s always a chance of failure. So I think it’s important that you really like whatever you’re doing. If you don’t like it, life is too short. If you like what you’re doing, you think about it even when you’re not working, it’s something your mind is draqwn to, and if you don’t like it, you just really can’t make it work, I think.You need to work super hard So what does super hard mean? Well, when my brother and I were staring our first company, instead of getting an apartment, we just rented a small office,and we slept on the couch, and we showered in the YMCA. We were so hard up that we had just one computer. So the website was uo during the day, and I was coding at night. 7day a week, all the time. So, work hard, like, every waking hour.（论你打算进军任何一个领域，就算你是一个十足的天才。所以我觉得重要的是，你真行喜欢你的事业。如果你不喜欢，人生可能是很短的。如果你喜欢你的事业，就算不工作时也在想着它，你全身心的投入进去，但是你如果不喜欢的话，我觉得就真的怎么也做不成这件事。你需要超级勤奋，那超级努力意味着什么？我和我弟弟创立第一家公司时，我们没有租公寓，就租了一间小办公室，我们睡在沙发上，去基督教青年会冲澡。我们拮据的只有一台电脑，电脑白天运作，我在夜里编程，一周七天往复循环，所以，在清醒的每个小时内都要努力。）—–埃隆·马斯克 3、The Boy·····遇见她花光了我所有运气 The Girl·····以他姓氏冠以自己的名字 —–《泰坦尼克号》 4、突然打开的隔墙面对面的惊喜—–网红料理 5、这香肠怎么卖的？一块钱俩、两块钱仨、三块钱四个，来十块钱的，十块钱是一个！ 6、原价一万九千八，现价998，看你这么漂亮收你九块九好了。 7、俄罗斯方块告诉了我们，成功会消失，错误会积累。贪吃蛇告诉了我们，越到后面越危险，最大的敌人是自己。愤怒的小鸟告诉了我们，当我们失败的时候，嘲笑我们的，都是猪！ 8、换个角度来说，俄罗斯方块告诉我们，合群跟随大众，随波逐流，我们就会消失，变得没有自我 。贪吃蛇告诉我们，不断的吸收负能量，不断的懒惰，害死我们的终究是自己 。愤怒的小鸟告诉我们，嘲笑我们的终究没有我们具有选择性，他们只有嘲笑的能力而我们具有打败别人的能力，变成猪的人类也只会嘲笑努力的人。 9、今天的砖头格外烫手，微风吹过我的脸庞，我很迷茫，也很无助，多希望有个富婆能看穿我的逞强，让我卸下所有伪装，走进她的心房。 10、间歇性雄心壮志，持续性混吃等死。我们都是语言的巨人，行动的矮子！持续性间歇雄心壮志，间歇性持续混吃等死。 11、活如猪狗，而不自知。 12、你不努力一下，怎么知道什么叫绝望。 13、找死和等死，你选择哪个？ 14、堕落过就会知道努力有多重要，辉煌过，就不愿意再回到那无能的深渊，希望为了梦想拼搏的人，能痛并快乐着，因为很多时候，努力，真的感觉很爽。 15、你需要充分努力才能足够幸运。 16、身在这个没有公道的世界上，自己就是公道。 17、握紧拳头，挥向生活。 18、逆天改命，绝不服输 19、如果你那天妥协了你就死掉了，唯有拼命的人才有生活。 20、你要努力，知道你认为谁也没有资格能配不上你。 21、人生值得未来可期。 22、真是因为异常艰难，活着才具有深刻的意义。没有什么比活更艰难，也没有什么比活着更加美好。 23、we live,we love,we lie 24、爱的时候不辜负人，玩的时候不辜负风景；睡觉时不辜负床，一个人时不辜负自己。 25、 “你愿意为我而死吗？” “我愿意” “不，那太简单了，换个问题，你愿意为我而活吗？”","categories":[],"tags":[]},{"title":"STH","slug":"STH","date":"2019-06-12T15:32:11.000Z","updated":"2019-06-29T15:55:31.596Z","comments":true,"path":"2019/06/12/STH/","link":"","permalink":"https://MingDa9916.github.io/2019/06/12/STH/","excerpt":"沉淀 耶鲁大学心态理念无条件自信即使再做错的时候不要想太多定时清除消极思想学会忘记痛苦为阳光记忆腾出空间敢于尝试敢于丢脸每天都是新的","text":"沉淀 耶鲁大学心态理念无条件自信即使再做错的时候不要想太多定时清除消极思想学会忘记痛苦为阳光记忆腾出空间敢于尝试敢于丢脸每天都是新的烦恼痛苦不过夜面对别人的优秀时发自内心的赞美做人的最高境界不是一味低调不是一味张扬而是始终如一的不卑不亢","categories":[{"name":"Life","slug":"Life","permalink":"https://MingDa9916.github.io/categories/Life/"}],"tags":[{"name":"日常积累","slug":"日常积累","permalink":"https://MingDa9916.github.io/tags/日常积累/"}]},{"title":"Real_Dream_One","slug":"Real-Dream","date":"2019-06-12T09:44:17.000Z","updated":"2019-06-12T16:11:32.517Z","comments":true,"path":"2019/06/12/Real-Dream/","link":"","permalink":"https://MingDa9916.github.io/2019/06/12/Real-Dream/","excerpt":"","text":"#","categories":[{"name":"Life","slug":"Life","permalink":"https://MingDa9916.github.io/categories/Life/"}],"tags":[{"name":"Dream","slug":"Dream","permalink":"https://MingDa9916.github.io/tags/Dream/"}]},{"title":"Sequence_LinkList_1","slug":"Sequence-LinkList","date":"2019-06-08T14:08:21.000Z","updated":"2019-06-17T16:39:40.503Z","comments":true,"path":"2019/06/08/Sequence-LinkList/","link":"","permalink":"https://MingDa9916.github.io/2019/06/08/Sequence-LinkList/","excerpt":"线性表_顺序表_2综合应用 1、设计一个递归算法，删除不带头节点的但聊表L中所有值为x的结点。","text":"线性表_顺序表_2综合应用 1、设计一个递归算法，删除不带头节点的但聊表L中所有值为x的结点。12345678910111213141516void Del_X_recursion(LinkList &amp;L, int x)&#123; if (L==NULL) return ; //递归出口 if (L-&gt;data != x) //L所指节点不等于x &#123; Del_X_recursion(L-&gt;next, x); //递归调用 return; //递归出口 &#125; //if (L-&gt;data == x) //若L所指节点的值为x LNode *p; p=L; L=L-&gt;next; delete p; Del_x_recursion(L,x); //递归调用&#125;2、带头节点的单链表L中，删除所有值为x的节点，并释放其空间，假设值为x的节点不唯一。 12345678910111213void Del_x(LinkList &amp;L, ElemType x)&#123;LNode *p = L-&gt;next, *pre = L, *q;while (p!=NULL)&#123; if (p-&gt;data != x)&#123; pre = p; p = p-&gt;next;&#125;q = p;pre-&gt;next = p-&gt;next;delete q; &#125;&#125; 3、设L为带头节点的单链表，编写算法实现从未到头书反向输出每个结点的值。 12345678void R_Print (LinkList &amp;L)&#123;if (L-&gt;next != NULL)&#123; R_Print (L-&gt;next);&#125;print (L-&gt;data);&#125; 4、带头结点的单链表L中删除一个最小值节点的高效算法（最小值唯一）。 1234567891011121314LinkList Del_Min(LinkList &amp;L)&#123;LNode *pre = L, *p = pre-&gt;next, *minpre = pre, *min = p;while (p!=NULL)&#123; if (min-&gt;data &lt; p-&gt;data)&#123; min = p; minpre = pre; &#125;pre = p;p = p-&gt;next;&#125;minpre-&gt;next = min-&gt;next;delete min ;return L;&#125; 5、O(1)的带头结点L单链表就地逆置。 12345678910void R_Link(LinkList &amp;L)&#123;LNode *p = L-&gt;next, *r = p-&gt;next, *pre;L-&gt;next = NULL;if (r != NULL)&#123; pre = p; p = p-&gt;next; r = p-&gt;next; p-&gt;next = pre;&#125;&#125; 6、有一个头结点的单链表L，设计一个算法使其元素递增有序。 12345678910111213141516171819202122232425262728293031323334353637LinkList D_Z(LinkList &amp;L)&#123;LinkList C = (LinkList*)malloc(sizeof(LNode));LNode *p = L-&gt;next, *min = p-&gt;next, *c = C, *q = c-&gt;next;while (p!=NULL)&#123; if(min-&gt;data &lt; p-&gt;data ) &#123; min = p; p = p-&gt;next; &#125;&#125;q-&gt;data = min-data;c = c-&gt;next;delete min;D_Z(LinkList &amp;L)return C;cz&#125;void Sort(LinkList &amp;L)&#123;LNode *p = L-&gt;next , *pre ;LNode *r = p-&gt;next //r保持*p后继结点指针，以保证不断链p-&gt;next = NULL ;p-&gt;r ;while (p != NULL) &#123; r = p-&gt;next ; pre = L ; while (per-&gt;next != NULL &amp;&amp; pre-&gt;next-&gt;data&lt;p-&gt;data) pre=pre-&gt;next ; //有序表中查找*p的前去结点*pre p-&gt;next = pre-&gt;next ; pre-&gt;next = p ; p = r ; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://MingDa9916.github.io/categories/数据结构与算法/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://MingDa9916.github.io/tags/顺序表/"}]},{"title":"2019/5/25","slug":"2019-5-25","date":"2019-05-25T07:20:50.000Z","updated":"2019-05-25T08:09:37.086Z","comments":true,"path":"2019/05/25/2019-5-25/","link":"","permalink":"https://MingDa9916.github.io/2019/05/25/2019-5-25/","excerpt":"","text":"你希不希望我在这里这是我目前要做的决定 不给我基本待遇！！！！ 因为什么都没 我看了一晚上和今天一上午 就我肯定希望你在这里，未来我们两个一起去做很多事情，如果你在这里，我们就可以在博士的时候就结婚。然后出国，回来可以在一起工作。但是，如果你不在这里，假设去了计算机领域，我们的交集会很少，但是你的机会应该会很多。 123456789101112131415161718192021222324252627282930313233343536373839404142我要搞清楚，就是我在这也很大可能没有相应的资格。。。。。就即使在这里我也不会一直在这里的这样的选择路也很难走必须要在学术上做出东西来我认为你想去985想去南方我的目的也不是就做个老师我要做东西出来我要项目的经费拿项目时间我不想你自己在这里我也不能确定你自己能不能做出好的东西来我也应该去浮去燥不了能双脚离地你就想清楚自己是否适合在实验室搞科妍我想做的就是尽快逃离这里，带你逃离这里。你觉得你去读计算机，你能打败那些一开始就接触计算机的人吗？第一我的目标就是拿学位！！！学位！！！学位！！！ 0客观就是不可能轨迹很少重合五年，你敢相信，但是上帝不相信","categories":[],"tags":[]},{"title":"间歇","slug":"间歇","date":"2019-05-20T14:56:19.000Z","updated":"2019-05-20T15:39:03.369Z","comments":true,"path":"2019/05/20/间歇/","link":"","permalink":"https://MingDa9916.github.io/2019/05/20/间歇/","excerpt":"放精神把肉体放养了小半天","text":"放精神把肉体放养了小半天 第一波考试结束了，还算顺利；总体复习过程心态不够好；太过急躁；考试过程字体控制不好；丑；要锻炼大篇幅的字迹工整三体；!!!平时一定要注意心态!!!虽然周围部分人因为存在感的缺失；同时没有自己的方向而昏恶游荡的；无视他们把；他们不在我的世界； 规程 学好主要科目；专业课开始走应试路线；刷数据结构，开始看网路；工程性完成数学刷题计划；英语背单词；开始做考研题偶尔六级；学不下去的时候看项目初体验；每天不可超过一小时；没周六收集资料最多两个是小时； 念 我依然爱你，只是不再喜欢你了!回忆与我都不爱说话偶尔我会想起她心里有一些牵挂有些爱却不得不各安天涯在夜深人静的时候想起她送的那些花还说过一些撕心裂肺的情话赌一把幸福的筹码在人来人往的街头想起她 晚安！明天早点滚起来！ ——2019-5-20撒","categories":[{"name":"Life","slug":"Life","permalink":"https://MingDa9916.github.io/categories/Life/"}],"tags":[{"name":"历程","slug":"历程","permalink":"https://MingDa9916.github.io/tags/历程/"}]},{"title":"Sequence_LinkList_0","slug":"SqList","date":"2019-05-14T05:45:13.000Z","updated":"2019-06-12T16:15:57.565Z","comments":true,"path":"2019/05/14/SqList/","link":"","permalink":"https://MingDa9916.github.io/2019/05/14/SqList/","excerpt":"线性表_顺序表_1综合应用","text":"线性表_顺序表_1综合应用 1、删除最小元素，返回并由最后元素填补 123456789101112131415bool Del_Min(SqList &amp;L , ElemType &amp;value)&#123; if(L.length == 0) return false ; value = L.data(0); int pos = 0; for(int i = 1 ; i&lt;L.length ; i++)&#123; if (value &lt; L.data(i))&#123; value = L.data(i); pos = i; &#125; &#125; L.data(pos) = L.data(L.length-1); L.length-- ; return true ;&#125; 2、顺序表元素逆置 123456789void Reverse(Sqlist &amp;L)&#123;//逆置只需操作内存地址中的值，无需做任何返回需求，所以用void返回ElemType temp ; //辅助变量for (int i = 0 ; i&lt;(L.length/2) ; i++)&#123; temp = L.data[i]; L.data(i) = L.data[L.length-i-1]; L.length[L.length-i-1] = temp ; &#125;&#125; 3、删除顺序表中所有值为x的元素1)、变量k记录所有不是x的元素1234567891011void Del_x(Sqlist &amp;L , ElemType x )&#123; int k = 0; for (int i = 0 ; i&lt;L.length ; i++)&#123; if (L.data[i] != x)&#123; L.data[k] = L.data[i]; k++; &#125; &#125;L.length = k;&#125;2)、变量k记录所有等于x元素的个数123456789void Del_x(Sqlist &amp;L ,ElemType x)&#123; int k = 0; for (int i = 0 ; i&lt;L.length ; i++)&#123; if (L.data[i] == x) k++; else L.data[i-k] = L.data[i]; &#125;L.length- = k;&#125;4、从有序表删除左右与给定值s~t之间的元素 123456789101112131415bool Del_s_t(SqList &amp;L , ElemType s , ElemType t )&#123; if (s&gt;=t || L.length &lt;= 0) return false ; for (int i = 0 ; i&lt;L.length&amp;&amp;L.data[i]&gt;s ; i++)&#123; if (i&gt;=L.length) return false ; &#125; for (int j = i ; j&lt;L.length ; j++)&#123; if (L.data[j]&gt;t) L.data[i++] = L.data[j]; &#125;L.length = i ; //不用减一是因为数组和表的下标差一return true ;&#125; 5、2011年408真题求两个等长升序序列的中位数 1234567891011121314151617181920212223242526272829//此题可用基础排序 | 快排 | 冒泡 等都看一手int M_Search (int A[] , int B [] , int n )&#123; int s1 = 0 ,d1 = n-1 , s2 = 0 , d2 = n-1 ; while (s1 != d1 || s2 != d2 )&#123; int m1 = (s1+d1)/2; int m2 = (s2+d2)/2; if (m2 == m1) return A[m1]; if (A[m1]&lt;B[m2]) if ((s1+d2)%2 == 0 )&#123; s1 = m1 ; d2 = m2 ; &#125; else &#123; s1 = m1 +1 ; d2 = m2 ; &#125; &#125; else &#123; if ((s2+d2)%2 == 0)&#123; d1 = m1; s2 = m2; &#125; else &#123; d1 = m1 ; s2 = m2+1 ; &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://MingDa9916.github.io/categories/数据结构与算法/"}],"tags":[{"name":"顺序表","slug":"顺序表","permalink":"https://MingDa9916.github.io/tags/顺序表/"}]}]}